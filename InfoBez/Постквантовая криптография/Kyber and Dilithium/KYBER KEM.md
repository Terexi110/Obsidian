## 1. Основные компоненты и параметры

**Параметры:**

- **Кольцо многочленов:**  

    Работает с кольцом Rq=Zq[X]/(Xn+1). Обычно выбирают    

    - n=256 — степень многочленов.

    - q=3329 — модуль (простое число).

- **Матрица A:**  

    Фиксированная (или генерируемая по seed) матрица многочленов размером k×k (где k зависит от выбранного уровня безопасности, например, для Kyber-512 используется k=2, для Kyber-768 — k=3, для Kyber-1024 — k=4). Каждый элемент матрицы — многочлен из Rq.

- **Секреты и шум:**  

    Секретные вектора и ошибки задаются как векторы многочленов, коэффициенты которых выбираются согласно небольшому дискретному распределению (например, центроцентрически симметричное распределение с малой дисперсией, близкое к биномиальному).

**Идея протокола:**  

Основная сложность, на которой базируется безопасность, — задача _Module Learning With Errors (Module-LWE)_. Она сводится к поиску секрета s по уравнению

b = A ⋅ s + e (в Rq),

где e — шум, выбранный случайно из распределения с малыми значениями. Из-за наличия шума восстановить s из A и b практически невозможно.

---

## 2. Фазы алгоритма

### 2.1 Генерация ключей (KeyGen)

**Цель:** Сгенерировать пару ключей:

- **Открытый ключ pk** — используется для шифрования (инкапсуляции).

- **Секретный ключ sk** — используется для расшифрования (деинкапсуляции).

**Пошаговое описание:**

1. **Генерация секретного вектора s и шумового вектора e:**  

    Для каждого из k элементов генерируются многочлены с малыми коэффициентами, выбранными из фиксированного распределения (например, биномиального распределения).

2. **Формирование матрицы A:**  

    Матрица A может быть определена фиксированным seed, от которого затем псевдослучайно генерируются её коэффициенты, либо может передаваться как часть системных параметров.

3. **Вычисление вектора b:**  

    Для открытого ключа вычисляется

    b = A ⋅ s + e

    Операция умножения и сложения выполняется в кольце Rq  (то есть все коэффициенты приводятся по модулю q).

4. **Формирование ключей:**

    - **Открытый ключ:** pk = (A, b).

    - **Секретный ключ:** sk = s (часто в реальной реализации дополнительно сохраняют информацию для защиты от атак с адаптивным выбором сообщений или побочных каналов).

**Псевдокод для KeyGen:**

python

`def KeyGen():     # Параметры: k, n, q     # Генерация секретного вектора s и ошибки e:     s = [SampleSmallPoly() for _ in range(k)]     e = [SampleSmallPoly() for _ in range(k)]          # Генерация матрицы A из seed (фиксированного)     A = GenerateMatrix(seed, k, n, q)  # A имеет размер k x k, каждый элемент — многочлен          # Вычисление b = A * s + e     b = []     for i in range(k):         poly_sum = PolyZero(n)         for j in range(k):             poly_sum = poly_add(poly_sum, poly_mul(A[i][j], s[j], q), q)         b.append(poly_add(poly_sum, e[i], q))          pk = (A, b)     sk = s     return pk, sk`

> **Примечание:** Функции `SampleSmallPoly()`, `GenerateMatrix()`, `poly_add()` и `poly_mul()` представляют операции выборки многочлена с малыми коэффициентами, генерации матрицы по seed, сложения и умножения многочленов в Rq.

---

### 2.2 Инкапсуляция (Encaps)

**Цель:** Отправитель генерирует зашифрованную капсулу, которая содержит зашифрованный симметричный ключ, и отправляет её получателю.

**Пошаговое описание:**

1. **Генерация случайного ключа и выбор шумовых многочленов:**

    - Выбирается случайное сообщение m (например, бинарный вектор фиксированной длины, который потом может использоваться как симметричный ключ или служить для генерации ключа).

    - Генерируются новые шумовые векторы r, e1 и e2​ (каждый из них — вектор из k многочленов с малыми коэффициентами).

2. **Вычисление промежуточных значений:**

    - Вычисляется u = A^T ⋅ r + e1​. Здесь A^T — транспонированная матрица A.

    - Вычисляется v = b^T ⋅ r + e2​. Затем к v добавляется сообщение m с применением процедур квантования или кодирования, чтобы обеспечить корректное восстановление m при деинкапсуляции.

3. **Формирование капсулы:**  

    Капсула c состоит из двух частей: c = (u, v).c = (u, v)c=(u,v)

**Псевдокод для Encaps:**

python

КопироватьРедактировать

`def Encaps(pk):     A, b = pk     # Генерация случайного симметричного ключа (например, 32 байта)     m = RandomMessage()          # Генерация шумовых векторов r, e1, e2     r  = [SampleSmallPoly() for _ in range(k)]     e1 = [SampleSmallPoly() for _ in range(k)]     e2 = SampleSmallPoly()  # Обычно один многочлен для v          # Вычисление u = A^T * r + e1     # Здесь A^T имеет размер k x k, и аналогичным образом производятся умножения     u = []     for i in range(k):         poly_sum = PolyZero(n)         for j in range(k):             poly_sum = poly_add(poly_sum, poly_mul(A[j][i], r[j], q), q)         u.append(poly_add(poly_sum, e1[i], q))          # Вычисление v = b^T * r + e2 + encode(m)     poly_sum = PolyZero(n)     for i in range(k):         poly_sum = poly_add(poly_sum, poly_mul(b[i], r[i], q), q)     # Функция encode() кодирует сообщение m в многочлен (или набор коэффициентов)     v = poly_add(poly_sum, e2, q)     v = poly_add(v, encode(m), q)          c = (u, v)     return c, m  # m используется для дальнейшей генерации симметричного ключа (например, для шифрования)`

> **Замечания:**

> 

> - Функция `encode(m)` отвечает за преобразование битовой строки mmm в представление в RqR_qRq​. Это может включать квантование, распределение битов по коэффициентам и т.д.

> - В реальных реализациях может применяться дополнительное хеширование или обработка для усиления безопасности.

---

### 2.3 Декапсуляция (Decaps)

**Цель:** Получатель, обладая секретным ключом sss, извлекает исходное сообщение mmm из капсулы c=(u,v)c = (u, v)c=(u,v).

**Пошаговое описание:**

4. **Вычисление промежуточного значения:**  

    Используя свой секрет sss, получатель вычисляет

    v′=uT⋅s,v' = u^T \cdot s,v′=uT⋅s,

    где uTu^TuT — транспонированное представление вектора uuu (если uuu представлен в виде вектора многочленов, операция сводится к поэлементному умножению с последующим суммированием).

5. **Извлечение сообщения:**  

    После вычисления v′v'v′ происходит операция обратного квантования (decoding) с

    m′=decode(v−v′).m' = decode(v - v').m′=decode(v−v′).

    Если ошибок не слишком много (что гарантируется корректно выбранными параметрами распределения шума), то m′m'm′ совпадёт с исходным mmm.

**Псевдокод для Decaps:**

python

КопироватьРедактировать

`def Decaps(c, sk):     u, v = c     s = sk  # Секретный вектор из k многочленов          # Вычисляем v' = u^T * s     poly_sum = PolyZero(n)     for i in range(k):         poly_sum = poly_add(poly_sum, poly_mul(u[i], s[i], q), q)     v_prime = poly_sum          # Вычитаем: v - v'     diff = poly_sub(v, v_prime, q)          # Применяем обратное квантование для восстановления m     m_recovered = decode(diff)     return m_recovered`

> **Замечания:**

> 

> - Функция `poly_sub(a, b, q)` вычисляет разность многочленов по модулю qqq.

> - Функция `decode(diff)` должна быть инверсия функции `encode(m)`. Обычно это достигается с помощью процедуры, сопоставляющей полученные коэффициенты с ближайшими допустимыми значениями, соответствующими битовым значениям mmm.

---

## 3. Пример работы на упрощённом варианте

Для иллюстрации рассмотрим упрощённый пример (с меньшими размерами параметров):

**Предположения:**

- Пусть n=4n = 4n=4 и q=17q = 17q=17 (для простоты примера; в реальности n=256n = 256n=256 и q=3329q = 3329q=3329).

- Пусть k=2k = 2k=2.

### Генерация ключей

6. **Выбираем секрет sss и ошибку eee:**  

    Например, пусть:

    - s1(X)=1+0X+2X2+0X3s_1(X) = 1 + 0X + 2X^2 + 0X^3s1​(X)=1+0X+2X2+0X3

    - s2(X)=0+1X+0X2+1X3s_2(X) = 0 + 1X + 0X^2 + 1X^3s2​(X)=0+1X+0X2+1X3  

        (коэффициенты выбираются из маленького множества, скажем, {−2,−1,0,1,2}\{-2, -1, 0, 1, 2\}{−2,−1,0,1,2}).

7. **Матрица AAA:**  

    Пусть для простоты

    A=(a11(X)a12(X)a21(X)a22(X))A = \begin{pmatrix} a_{11}(X) & a_{12}(X)\\[1mm] a_{21}(X) & a_{22}(X) \end{pmatrix}A=(a11​(X)a21​(X)​a12​(X)a22​(X)​)

    где, например,

    - a11(X)=3+5X+0X2+2X3a_{11}(X) = 3 + 5X + 0X^2 + 2X^3a11​(X)=3+5X+0X2+2X3

    - a12(X)=1+2X+4X2+0X3a_{12}(X) = 1 + 2X + 4X^2 + 0X^3a12​(X)=1+2X+4X2+0X3

    - a21(X)=2+1X+3X2+3X3a_{21}(X) = 2 + 1X + 3X^2 + 3X^3a21​(X)=2+1X+3X2+3X3

    - a22(X)=0+4X+1X2+2X3a_{22}(X) = 0 + 4X + 1X^2 + 2X^3a22​(X)=0+4X+1X2+2X3.

8. **Вычисляем b=A⋅s+eb = A \cdot s + eb=A⋅s+e:**  

    Пусть шум eee также состоит из двух многочленов с малыми коэффициентами, например:

    - e1(X)=1+0X+(−1)X2+0X3e_1(X) = 1 + 0X + (-1)X^2 + 0X^3e1​(X)=1+0X+(−1)X2+0X3

    - e2(X)=0+1X+0X2+(−1)X3e_2(X) = 0 + 1X + 0X^2 + (-1)X^3e2​(X)=0+1X+0X2+(−1)X3.

    Для первого элемента b1(X)b_1(X)b1​(X):

    - Вычисляем a11(X)⋅s1(X)a_{11}(X) \cdot s_1(X)a11​(X)⋅s1​(X) и a12(X)⋅s2(X)a_{12}(X) \cdot s_2(X)a12​(X)⋅s2​(X) по модулю 171717 с учётом свёртки по X4+1X^4+1X4+1.  

        Аналогично для b2(X)b_2(X)b2​(X).  

        (Подробные вычисления выполняются по правилам умножения многочленов в кольце RqR_qRq​.)

9. **Получаем открытый ключ:**  

    pk=(A,b)pk = (A, b)pk=(A,b).

### Инкапсуляция

Предположим, отправитель выбирает сообщение mmm (например, 4-битное представление, закодированное в многочлене). Пусть:

- mmm после кодирования даёт многочлен m(X)=1+0X+1X2+0X3m(X) = 1 + 0X + 1X^2 + 0X^3m(X)=1+0X+1X2+0X3.

Отправитель генерирует шумовые многочлены r,e1r, e_1r,e1​ (вектор длины 2) и e2e_2e2​ (один многочлен). Затем:

10. Вычисляет u=AT⋅r+e1u = A^T \cdot r + e_1u=AT⋅r+e1​.  

    Если r=(r1(X),r2(X))r = (r_1(X), r_2(X))r=(r1​(X),r2​(X)), то u1(X)=a11(X)⋅r1(X)+a21(X)⋅r2(X)+e1,1(X)u_1(X) = a_{11}(X) \cdot r_1(X) + a_{21}(X) \cdot r_2(X) + e_{1,1}(X)u1​(X)=a11​(X)⋅r1​(X)+a21​(X)⋅r2​(X)+e1,1​(X) и u2(X)=a12(X)⋅r1(X)+a22(X)⋅r2(X)+e1,2(X).u_2(X) = a_{12}(X) \cdot r_1(X) + a_{22}(X) \cdot r_2(X) + e_{1,2}(X).u2​(X)=a12​(X)⋅r1​(X)+a22​(X)⋅r2​(X)+e1,2​(X).

11. Вычисляет v=bT⋅r+e2+encode(m)v = b^T \cdot r + e_2 + encode(m)v=bT⋅r+e2​+encode(m).  

    Например, v(X)=b1(X)⋅r1(X)+b2(X)⋅r2(X)+e2(X)+encode(m(X)).v(X) = b_1(X) \cdot r_1(X) + b_2(X) \cdot r_2(X) + e_2(X) + encode(m(X)).v(X)=b1​(X)⋅r1​(X)+b2​(X)⋅r2​(X)+e2​(X)+encode(m(X)).

Капсула c=(u,v)c = (u, v)c=(u,v) отправляется получателю.

### Декапсуляция

Получатель, зная секрет s=(s1,s2)s = (s_1, s_2)s=(s1​,s2​), выполняет следующие шаги:

12. Вычисляет v′=u1(X)⋅s1(X)+u2(X)⋅s2(X)v' = u_1(X) \cdot s_1(X) + u_2(X) \cdot s_2(X)v′=u1​(X)⋅s1​(X)+u2​(X)⋅s2​(X).

13. Вычисляет разность v(X)−v′(X)v(X) - v'(X)v(X)−v′(X), которая должна приблизительно равняться encode(m(X))encode(m(X))encode(m(X)) (так как шумы, внесённые на этапах, малы).

14. Применяет функцию декодирования decode(⋅)decode(\cdot)decode(⋅), чтобы восстановить исходное сообщение mmm.

Если параметры и распределения шума выбраны корректно, вероятность ошибки декодирования очень мала.

---

## 4. Заключительные замечания

- **Кодирование и декодирование:**  

    Для того чтобы сообщение mmm было корректно восстановлено, Kyber применяет процедуры квантования. Обычно часть коэффициентов многочлена vvv делят на фиксированный делитель и сравнивают с пороговыми значениями для определения битов mmm. Эти процедуры могут быть довольно детализированы в спецификации.

- **Оптимизации:**  

    Реальные реализации Kyber используют оптимизированные алгоритмы для умножения многочленов (например, с использованием Number Theoretic Transform, NTT) для повышения производительности.

- **Безопасность:**  

    Защита основана на сложности задачи MLWE. Даже при наличии квантовых компьютеров, эффективное решение этой задачи остаётся маловероятным при корректном выборе параметров.

- **Практическое применение:**  

    Kyber уже интегрируется в гибридные криптографические протоколы, где помимо классических алгоритмов (например, RSA или ECC) используется и постквантовая защита на основе Kyber. Это обеспечивает защиту как от классических, так и квантовых атак.

---

## 5. Итоговый обзор с примерами

15. **KeyGen:**

    - Генерируется секретный вектор sss (например, [s1,s2][s_1, s_2][s1​,s2​]).

    - Вычисляется b=A⋅s+eb = A \cdot s + eb=A⋅s+e для получения открытого ключа pk=(A,b)pk = (A, b)pk=(A,b).

16. **Encaps:**

    - Отправитель выбирает случайное сообщение mmm (например, m=10102m = 1010_2m=10102​ после кодирования в многочлен).

    - Генерируются шумовые векторы rrr, e1e_1e1​ и e2e_2e2​.

    - Вычисляются u=AT⋅r+e1u = A^T \cdot r + e_1u=AT⋅r+e1​ и v=bT⋅r+e2+encode(m)v = b^T \cdot r + e_2 + encode(m)v=bT⋅r+e2​+encode(m).

    - Формируется капсула c=(u,v)c = (u, v)c=(u,v) и отправляется получателю.

17. **Decaps:**

    - Получатель вычисляет v′=uT⋅sv' = u^T \cdot sv′=uT⋅s.

    - Восстанавливает сообщение как m=decode(v−v′)m = decode(v - v')m=decode(v−v′).

Эта схема обеспечивает квантовую устойчивость благодаря трудности задачи MLWE, а за счёт применения небольшого шума и процедур квантования достигается как безопасность, так и практическая эффективность.